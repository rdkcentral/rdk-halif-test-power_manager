/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockplat_power.h"

static const char* CMockString_PLAT_API_DetemineClockSpeeds = "PLAT_API_DetemineClockSpeeds";
static const char* CMockString_PLAT_API_GetClockSpeed = "PLAT_API_GetClockSpeed";
static const char* CMockString_PLAT_API_GetPowerState = "PLAT_API_GetPowerState";
static const char* CMockString_PLAT_API_GetTempThresholds = "PLAT_API_GetTempThresholds";
static const char* CMockString_PLAT_API_GetTemperature = "PLAT_API_GetTemperature";
static const char* CMockString_PLAT_API_SetClockSpeed = "PLAT_API_SetClockSpeed";
static const char* CMockString_PLAT_API_SetPowerState = "PLAT_API_SetPowerState";
static const char* CMockString_PLAT_API_SetTempThresholds = "PLAT_API_SetTempThresholds";
static const char* CMockString_PLAT_INIT = "PLAT_INIT";
static const char* CMockString_PLAT_TERM = "PLAT_TERM";
static const char* CMockString_cpu_rate_Minimal = "cpu_rate_Minimal";
static const char* CMockString_cpu_rate_Normal = "cpu_rate_Normal";
static const char* CMockString_cpu_rate_Scaled = "cpu_rate_Scaled";
static const char* CMockString_curState = "curState";
static const char* CMockString_curTemperature = "curTemperature";
static const char* CMockString_newState = "newState";
static const char* CMockString_speed = "speed";
static const char* CMockString_tempCritical = "tempCritical";
static const char* CMockString_tempHigh = "tempHigh";
static const char* CMockString_wifiTemperature = "wifiTemperature";

typedef struct _CMOCK_PLAT_INIT_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  pmError_t ReturnVal;

} CMOCK_PLAT_INIT_CALL_INSTANCE;

typedef struct _CMOCK_PLAT_API_SetPowerState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  pmError_t ReturnVal;
  IARM_Bus_PWRMgr_PowerState_t Expected_newState;

} CMOCK_PLAT_API_SetPowerState_CALL_INSTANCE;

typedef struct _CMOCK_PLAT_API_GetPowerState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  pmError_t ReturnVal;
  IARM_Bus_PWRMgr_PowerState_t* Expected_curState;

} CMOCK_PLAT_API_GetPowerState_CALL_INSTANCE;

typedef struct _CMOCK_PLAT_API_GetTemperature_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  pmError_t ReturnVal;
  IARM_Bus_PWRMgr_ThermalState_t* Expected_curState;
  float* Expected_curTemperature;
  float* Expected_wifiTemperature;

} CMOCK_PLAT_API_GetTemperature_CALL_INSTANCE;

typedef struct _CMOCK_PLAT_API_SetTempThresholds_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  pmError_t ReturnVal;
  float Expected_tempHigh;
  float Expected_tempCritical;

} CMOCK_PLAT_API_SetTempThresholds_CALL_INSTANCE;

typedef struct _CMOCK_PLAT_API_GetTempThresholds_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  pmError_t ReturnVal;
  float* Expected_tempHigh;
  float* Expected_tempCritical;

} CMOCK_PLAT_API_GetTempThresholds_CALL_INSTANCE;

typedef struct _CMOCK_PLAT_API_DetemineClockSpeeds_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  pmError_t ReturnVal;
  uint32_t* Expected_cpu_rate_Normal;
  uint32_t* Expected_cpu_rate_Scaled;
  uint32_t* Expected_cpu_rate_Minimal;

} CMOCK_PLAT_API_DetemineClockSpeeds_CALL_INSTANCE;

typedef struct _CMOCK_PLAT_API_SetClockSpeed_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  pmError_t ReturnVal;
  uint32_t Expected_speed;

} CMOCK_PLAT_API_SetClockSpeed_CALL_INSTANCE;

typedef struct _CMOCK_PLAT_API_GetClockSpeed_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  pmError_t ReturnVal;
  uint32_t* Expected_speed;

} CMOCK_PLAT_API_GetClockSpeed_CALL_INSTANCE;

typedef struct _CMOCK_PLAT_TERM_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_PLAT_TERM_CALL_INSTANCE;

static struct Mockplat_powerInstance
{
  CMOCK_MEM_INDEX_TYPE PLAT_INIT_CallInstance;
  CMOCK_MEM_INDEX_TYPE PLAT_API_SetPowerState_CallInstance;
  CMOCK_MEM_INDEX_TYPE PLAT_API_GetPowerState_CallInstance;
  CMOCK_MEM_INDEX_TYPE PLAT_API_GetTemperature_CallInstance;
  CMOCK_MEM_INDEX_TYPE PLAT_API_SetTempThresholds_CallInstance;
  CMOCK_MEM_INDEX_TYPE PLAT_API_GetTempThresholds_CallInstance;
  CMOCK_MEM_INDEX_TYPE PLAT_API_DetemineClockSpeeds_CallInstance;
  CMOCK_MEM_INDEX_TYPE PLAT_API_SetClockSpeed_CallInstance;
  CMOCK_MEM_INDEX_TYPE PLAT_API_GetClockSpeed_CallInstance;
  CMOCK_MEM_INDEX_TYPE PLAT_TERM_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockplat_power_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.PLAT_INIT_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_PLAT_INIT);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.PLAT_API_SetPowerState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_PLAT_API_SetPowerState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.PLAT_API_GetPowerState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_PLAT_API_GetPowerState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.PLAT_API_GetTemperature_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_PLAT_API_GetTemperature);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.PLAT_API_SetTempThresholds_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_PLAT_API_SetTempThresholds);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.PLAT_API_GetTempThresholds_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_PLAT_API_GetTempThresholds);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.PLAT_API_DetemineClockSpeeds_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_PLAT_API_DetemineClockSpeeds);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.PLAT_API_SetClockSpeed_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_PLAT_API_SetClockSpeed);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.PLAT_API_GetClockSpeed_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_PLAT_API_GetClockSpeed);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.PLAT_TERM_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_PLAT_TERM);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockplat_power_Init(void)
{
  Mockplat_power_Destroy();
}

void Mockplat_power_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

pmError_t PLAT_INIT(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PLAT_INIT_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_PLAT_INIT);
  cmock_call_instance = (CMOCK_PLAT_INIT_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PLAT_INIT_CallInstance);
  Mock.PLAT_INIT_CallInstance = CMock_Guts_MemNext(Mock.PLAT_INIT_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void PLAT_INIT_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, pmError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PLAT_INIT_CALL_INSTANCE));
  CMOCK_PLAT_INIT_CALL_INSTANCE* cmock_call_instance = (CMOCK_PLAT_INIT_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.PLAT_INIT_CallInstance = CMock_Guts_MemChain(Mock.PLAT_INIT_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(pmError_t[sizeof(cmock_to_return) == sizeof(pmError_t) ? 1 : -1])); /* add pmError_t to :treat_as_array if this causes an error */
}

pmError_t PLAT_API_SetPowerState(IARM_Bus_PWRMgr_PowerState_t newState)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PLAT_API_SetPowerState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_PLAT_API_SetPowerState);
  cmock_call_instance = (CMOCK_PLAT_API_SetPowerState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PLAT_API_SetPowerState_CallInstance);
  Mock.PLAT_API_SetPowerState_CallInstance = CMock_Guts_MemNext(Mock.PLAT_API_SetPowerState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_SetPowerState,CMockString_newState);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_newState), (void*)(&newState), sizeof(IARM_Bus_PWRMgr_PowerState_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_PLAT_API_SetPowerState(CMOCK_PLAT_API_SetPowerState_CALL_INSTANCE* cmock_call_instance, IARM_Bus_PWRMgr_PowerState_t newState);
void CMockExpectParameters_PLAT_API_SetPowerState(CMOCK_PLAT_API_SetPowerState_CALL_INSTANCE* cmock_call_instance, IARM_Bus_PWRMgr_PowerState_t newState)
{
  memcpy((void*)(&cmock_call_instance->Expected_newState), (void*)(&newState),
         sizeof(IARM_Bus_PWRMgr_PowerState_t[sizeof(newState) == sizeof(IARM_Bus_PWRMgr_PowerState_t) ? 1 : -1])); /* add IARM_Bus_PWRMgr_PowerState_t to :treat_as_array if this causes an error */
}

void PLAT_API_SetPowerState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IARM_Bus_PWRMgr_PowerState_t newState, pmError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PLAT_API_SetPowerState_CALL_INSTANCE));
  CMOCK_PLAT_API_SetPowerState_CALL_INSTANCE* cmock_call_instance = (CMOCK_PLAT_API_SetPowerState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.PLAT_API_SetPowerState_CallInstance = CMock_Guts_MemChain(Mock.PLAT_API_SetPowerState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_PLAT_API_SetPowerState(cmock_call_instance, newState);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(pmError_t[sizeof(cmock_to_return) == sizeof(pmError_t) ? 1 : -1])); /* add pmError_t to :treat_as_array if this causes an error */
}

pmError_t PLAT_API_GetPowerState(IARM_Bus_PWRMgr_PowerState_t* curState)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PLAT_API_GetPowerState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_PLAT_API_GetPowerState);
  cmock_call_instance = (CMOCK_PLAT_API_GetPowerState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PLAT_API_GetPowerState_CallInstance);
  Mock.PLAT_API_GetPowerState_CallInstance = CMock_Guts_MemNext(Mock.PLAT_API_GetPowerState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_GetPowerState,CMockString_curState);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_curState), (void*)(curState), sizeof(IARM_Bus_PWRMgr_PowerState_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_PLAT_API_GetPowerState(CMOCK_PLAT_API_GetPowerState_CALL_INSTANCE* cmock_call_instance, IARM_Bus_PWRMgr_PowerState_t* curState);
void CMockExpectParameters_PLAT_API_GetPowerState(CMOCK_PLAT_API_GetPowerState_CALL_INSTANCE* cmock_call_instance, IARM_Bus_PWRMgr_PowerState_t* curState)
{
  cmock_call_instance->Expected_curState = curState;
}

void PLAT_API_GetPowerState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IARM_Bus_PWRMgr_PowerState_t* curState, pmError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PLAT_API_GetPowerState_CALL_INSTANCE));
  CMOCK_PLAT_API_GetPowerState_CALL_INSTANCE* cmock_call_instance = (CMOCK_PLAT_API_GetPowerState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.PLAT_API_GetPowerState_CallInstance = CMock_Guts_MemChain(Mock.PLAT_API_GetPowerState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_PLAT_API_GetPowerState(cmock_call_instance, curState);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(pmError_t[sizeof(cmock_to_return) == sizeof(pmError_t) ? 1 : -1])); /* add pmError_t to :treat_as_array if this causes an error */
}

pmError_t PLAT_API_GetTemperature(IARM_Bus_PWRMgr_ThermalState_t* curState, float* curTemperature, float* wifiTemperature)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PLAT_API_GetTemperature_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_PLAT_API_GetTemperature);
  cmock_call_instance = (CMOCK_PLAT_API_GetTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PLAT_API_GetTemperature_CallInstance);
  Mock.PLAT_API_GetTemperature_CallInstance = CMock_Guts_MemNext(Mock.PLAT_API_GetTemperature_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_GetTemperature,CMockString_curState);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_curState), (void*)(curState), sizeof(IARM_Bus_PWRMgr_ThermalState_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_GetTemperature,CMockString_curTemperature);
    if (cmock_call_instance->Expected_curTemperature == NULL)
      { UNITY_TEST_ASSERT_NULL(curTemperature, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_curTemperature, curTemperature, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_GetTemperature,CMockString_wifiTemperature);
    if (cmock_call_instance->Expected_wifiTemperature == NULL)
      { UNITY_TEST_ASSERT_NULL(wifiTemperature, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_wifiTemperature, wifiTemperature, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_PLAT_API_GetTemperature(CMOCK_PLAT_API_GetTemperature_CALL_INSTANCE* cmock_call_instance, IARM_Bus_PWRMgr_ThermalState_t* curState, float* curTemperature, float* wifiTemperature);
void CMockExpectParameters_PLAT_API_GetTemperature(CMOCK_PLAT_API_GetTemperature_CALL_INSTANCE* cmock_call_instance, IARM_Bus_PWRMgr_ThermalState_t* curState, float* curTemperature, float* wifiTemperature)
{
  cmock_call_instance->Expected_curState = curState;
  cmock_call_instance->Expected_curTemperature = curTemperature;
  cmock_call_instance->Expected_wifiTemperature = wifiTemperature;
}

void PLAT_API_GetTemperature_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IARM_Bus_PWRMgr_ThermalState_t* curState, float* curTemperature, float* wifiTemperature, pmError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PLAT_API_GetTemperature_CALL_INSTANCE));
  CMOCK_PLAT_API_GetTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_PLAT_API_GetTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.PLAT_API_GetTemperature_CallInstance = CMock_Guts_MemChain(Mock.PLAT_API_GetTemperature_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_PLAT_API_GetTemperature(cmock_call_instance, curState, curTemperature, wifiTemperature);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(pmError_t[sizeof(cmock_to_return) == sizeof(pmError_t) ? 1 : -1])); /* add pmError_t to :treat_as_array if this causes an error */
}

pmError_t PLAT_API_SetTempThresholds(float tempHigh, float tempCritical)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PLAT_API_SetTempThresholds_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_PLAT_API_SetTempThresholds);
  cmock_call_instance = (CMOCK_PLAT_API_SetTempThresholds_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PLAT_API_SetTempThresholds_CallInstance);
  Mock.PLAT_API_SetTempThresholds_CallInstance = CMock_Guts_MemNext(Mock.PLAT_API_SetTempThresholds_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_SetTempThresholds,CMockString_tempHigh);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_tempHigh, tempHigh, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_SetTempThresholds,CMockString_tempCritical);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_tempCritical, tempCritical, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_PLAT_API_SetTempThresholds(CMOCK_PLAT_API_SetTempThresholds_CALL_INSTANCE* cmock_call_instance, float tempHigh, float tempCritical);
void CMockExpectParameters_PLAT_API_SetTempThresholds(CMOCK_PLAT_API_SetTempThresholds_CALL_INSTANCE* cmock_call_instance, float tempHigh, float tempCritical)
{
  cmock_call_instance->Expected_tempHigh = tempHigh;
  cmock_call_instance->Expected_tempCritical = tempCritical;
}

void PLAT_API_SetTempThresholds_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, float tempHigh, float tempCritical, pmError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PLAT_API_SetTempThresholds_CALL_INSTANCE));
  CMOCK_PLAT_API_SetTempThresholds_CALL_INSTANCE* cmock_call_instance = (CMOCK_PLAT_API_SetTempThresholds_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.PLAT_API_SetTempThresholds_CallInstance = CMock_Guts_MemChain(Mock.PLAT_API_SetTempThresholds_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_PLAT_API_SetTempThresholds(cmock_call_instance, tempHigh, tempCritical);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(pmError_t[sizeof(cmock_to_return) == sizeof(pmError_t) ? 1 : -1])); /* add pmError_t to :treat_as_array if this causes an error */
}

pmError_t PLAT_API_GetTempThresholds(float* tempHigh, float* tempCritical)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PLAT_API_GetTempThresholds_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_PLAT_API_GetTempThresholds);
  cmock_call_instance = (CMOCK_PLAT_API_GetTempThresholds_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PLAT_API_GetTempThresholds_CallInstance);
  Mock.PLAT_API_GetTempThresholds_CallInstance = CMock_Guts_MemNext(Mock.PLAT_API_GetTempThresholds_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_GetTempThresholds,CMockString_tempHigh);
    if (cmock_call_instance->Expected_tempHigh == NULL)
      { UNITY_TEST_ASSERT_NULL(tempHigh, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_tempHigh, tempHigh, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_GetTempThresholds,CMockString_tempCritical);
    if (cmock_call_instance->Expected_tempCritical == NULL)
      { UNITY_TEST_ASSERT_NULL(tempCritical, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_tempCritical, tempCritical, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_PLAT_API_GetTempThresholds(CMOCK_PLAT_API_GetTempThresholds_CALL_INSTANCE* cmock_call_instance, float* tempHigh, float* tempCritical);
void CMockExpectParameters_PLAT_API_GetTempThresholds(CMOCK_PLAT_API_GetTempThresholds_CALL_INSTANCE* cmock_call_instance, float* tempHigh, float* tempCritical)
{
  cmock_call_instance->Expected_tempHigh = tempHigh;
  cmock_call_instance->Expected_tempCritical = tempCritical;
}

void PLAT_API_GetTempThresholds_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, float* tempHigh, float* tempCritical, pmError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PLAT_API_GetTempThresholds_CALL_INSTANCE));
  CMOCK_PLAT_API_GetTempThresholds_CALL_INSTANCE* cmock_call_instance = (CMOCK_PLAT_API_GetTempThresholds_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.PLAT_API_GetTempThresholds_CallInstance = CMock_Guts_MemChain(Mock.PLAT_API_GetTempThresholds_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_PLAT_API_GetTempThresholds(cmock_call_instance, tempHigh, tempCritical);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(pmError_t[sizeof(cmock_to_return) == sizeof(pmError_t) ? 1 : -1])); /* add pmError_t to :treat_as_array if this causes an error */
}

pmError_t PLAT_API_DetemineClockSpeeds(uint32_t* cpu_rate_Normal, uint32_t* cpu_rate_Scaled, uint32_t* cpu_rate_Minimal)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PLAT_API_DetemineClockSpeeds_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_PLAT_API_DetemineClockSpeeds);
  cmock_call_instance = (CMOCK_PLAT_API_DetemineClockSpeeds_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PLAT_API_DetemineClockSpeeds_CallInstance);
  Mock.PLAT_API_DetemineClockSpeeds_CallInstance = CMock_Guts_MemNext(Mock.PLAT_API_DetemineClockSpeeds_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_DetemineClockSpeeds,CMockString_cpu_rate_Normal);
    if (cmock_call_instance->Expected_cpu_rate_Normal == NULL)
      { UNITY_TEST_ASSERT_NULL(cpu_rate_Normal, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_cpu_rate_Normal, cpu_rate_Normal, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_DetemineClockSpeeds,CMockString_cpu_rate_Scaled);
    if (cmock_call_instance->Expected_cpu_rate_Scaled == NULL)
      { UNITY_TEST_ASSERT_NULL(cpu_rate_Scaled, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_cpu_rate_Scaled, cpu_rate_Scaled, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_DetemineClockSpeeds,CMockString_cpu_rate_Minimal);
    if (cmock_call_instance->Expected_cpu_rate_Minimal == NULL)
      { UNITY_TEST_ASSERT_NULL(cpu_rate_Minimal, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_cpu_rate_Minimal, cpu_rate_Minimal, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_PLAT_API_DetemineClockSpeeds(CMOCK_PLAT_API_DetemineClockSpeeds_CALL_INSTANCE* cmock_call_instance, uint32_t* cpu_rate_Normal, uint32_t* cpu_rate_Scaled, uint32_t* cpu_rate_Minimal);
void CMockExpectParameters_PLAT_API_DetemineClockSpeeds(CMOCK_PLAT_API_DetemineClockSpeeds_CALL_INSTANCE* cmock_call_instance, uint32_t* cpu_rate_Normal, uint32_t* cpu_rate_Scaled, uint32_t* cpu_rate_Minimal)
{
  cmock_call_instance->Expected_cpu_rate_Normal = cpu_rate_Normal;
  cmock_call_instance->Expected_cpu_rate_Scaled = cpu_rate_Scaled;
  cmock_call_instance->Expected_cpu_rate_Minimal = cpu_rate_Minimal;
}

void PLAT_API_DetemineClockSpeeds_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* cpu_rate_Normal, uint32_t* cpu_rate_Scaled, uint32_t* cpu_rate_Minimal, pmError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PLAT_API_DetemineClockSpeeds_CALL_INSTANCE));
  CMOCK_PLAT_API_DetemineClockSpeeds_CALL_INSTANCE* cmock_call_instance = (CMOCK_PLAT_API_DetemineClockSpeeds_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.PLAT_API_DetemineClockSpeeds_CallInstance = CMock_Guts_MemChain(Mock.PLAT_API_DetemineClockSpeeds_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_PLAT_API_DetemineClockSpeeds(cmock_call_instance, cpu_rate_Normal, cpu_rate_Scaled, cpu_rate_Minimal);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(pmError_t[sizeof(cmock_to_return) == sizeof(pmError_t) ? 1 : -1])); /* add pmError_t to :treat_as_array if this causes an error */
}

pmError_t PLAT_API_SetClockSpeed(uint32_t speed)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PLAT_API_SetClockSpeed_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_PLAT_API_SetClockSpeed);
  cmock_call_instance = (CMOCK_PLAT_API_SetClockSpeed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PLAT_API_SetClockSpeed_CallInstance);
  Mock.PLAT_API_SetClockSpeed_CallInstance = CMock_Guts_MemNext(Mock.PLAT_API_SetClockSpeed_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_SetClockSpeed,CMockString_speed);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_speed, speed, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_PLAT_API_SetClockSpeed(CMOCK_PLAT_API_SetClockSpeed_CALL_INSTANCE* cmock_call_instance, uint32_t speed);
void CMockExpectParameters_PLAT_API_SetClockSpeed(CMOCK_PLAT_API_SetClockSpeed_CALL_INSTANCE* cmock_call_instance, uint32_t speed)
{
  cmock_call_instance->Expected_speed = speed;
}

void PLAT_API_SetClockSpeed_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t speed, pmError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PLAT_API_SetClockSpeed_CALL_INSTANCE));
  CMOCK_PLAT_API_SetClockSpeed_CALL_INSTANCE* cmock_call_instance = (CMOCK_PLAT_API_SetClockSpeed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.PLAT_API_SetClockSpeed_CallInstance = CMock_Guts_MemChain(Mock.PLAT_API_SetClockSpeed_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_PLAT_API_SetClockSpeed(cmock_call_instance, speed);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(pmError_t[sizeof(cmock_to_return) == sizeof(pmError_t) ? 1 : -1])); /* add pmError_t to :treat_as_array if this causes an error */
}

pmError_t PLAT_API_GetClockSpeed(uint32_t* speed)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PLAT_API_GetClockSpeed_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_PLAT_API_GetClockSpeed);
  cmock_call_instance = (CMOCK_PLAT_API_GetClockSpeed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PLAT_API_GetClockSpeed_CallInstance);
  Mock.PLAT_API_GetClockSpeed_CallInstance = CMock_Guts_MemNext(Mock.PLAT_API_GetClockSpeed_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_PLAT_API_GetClockSpeed,CMockString_speed);
    if (cmock_call_instance->Expected_speed == NULL)
      { UNITY_TEST_ASSERT_NULL(speed, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_speed, speed, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_PLAT_API_GetClockSpeed(CMOCK_PLAT_API_GetClockSpeed_CALL_INSTANCE* cmock_call_instance, uint32_t* speed);
void CMockExpectParameters_PLAT_API_GetClockSpeed(CMOCK_PLAT_API_GetClockSpeed_CALL_INSTANCE* cmock_call_instance, uint32_t* speed)
{
  cmock_call_instance->Expected_speed = speed;
}

void PLAT_API_GetClockSpeed_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* speed, pmError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PLAT_API_GetClockSpeed_CALL_INSTANCE));
  CMOCK_PLAT_API_GetClockSpeed_CALL_INSTANCE* cmock_call_instance = (CMOCK_PLAT_API_GetClockSpeed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.PLAT_API_GetClockSpeed_CallInstance = CMock_Guts_MemChain(Mock.PLAT_API_GetClockSpeed_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_PLAT_API_GetClockSpeed(cmock_call_instance, speed);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(pmError_t[sizeof(cmock_to_return) == sizeof(pmError_t) ? 1 : -1])); /* add pmError_t to :treat_as_array if this causes an error */
}

void PLAT_TERM(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PLAT_TERM_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_PLAT_TERM);
  cmock_call_instance = (CMOCK_PLAT_TERM_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PLAT_TERM_CallInstance);
  Mock.PLAT_TERM_CallInstance = CMock_Guts_MemNext(Mock.PLAT_TERM_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void PLAT_TERM_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PLAT_TERM_CALL_INSTANCE));
  CMOCK_PLAT_TERM_CALL_INSTANCE* cmock_call_instance = (CMOCK_PLAT_TERM_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.PLAT_TERM_CallInstance = CMock_Guts_MemChain(Mock.PLAT_TERM_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

